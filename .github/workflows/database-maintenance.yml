# 数据库维护工作流（默认禁用）
name: Database Maintenance

on:
  # 默认禁用自动触发，需要手动启用
  # schedule:
  #   # 每天凌晨 3:00 UTC 执行数据库维护
  #   - cron: "0 3 * * *"
  #   # 每周日凌晨 1:00 UTC 执行深度维护
  #   - cron: "0 1 * * 0"
  workflow_dispatch:
    inputs:
      enable_workflow:
        description: "启用工作流（默认禁用）"
        required: true
        default: false
        type: boolean
      maintenance_type:
        description: "维护类型"
        required: true
        default: "routine"
        type: choice
        options:
          - routine
          - deep
          - emergency
          - vacuum
          - analyze
          - reindex
      environment:
        description: "目标环境"
        required: true
        default: "staging"
        type: choice
        options:
          - staging
          - production
      skip_backup:
        description: "跳过备份"
        required: false
        default: false
        type: boolean

env:
  MAINTENANCE_TYPE: ${{ inputs.maintenance_type || (github.event.schedule == '0 1 * * 0' && 'deep' || 'routine') }}
  ENVIRONMENT: ${{ inputs.environment || 'staging' }}
  SKIP_BACKUP: ${{ inputs.skip_backup || 'false' }}

jobs:
  # ===== 预检查 =====
  pre-check:
    name: 维护前检查
    runs-on: ubuntu-latest
    outputs:
      can-proceed: ${{ steps.check.outputs.can-proceed }}
      db-size: ${{ steps.check.outputs.db-size }}
      active-connections: ${{ steps.check.outputs.active-connections }}

    steps:
      - name: 检出代码
        uses: actions/checkout@v4

      - name: 设置环境变量
        run: |
          if [ "$ENVIRONMENT" = "production" ]; then
            echo "DB_HOST=${{ secrets.PROD_DB_HOST }}" >> $GITHUB_ENV
            echo "DB_PORT=${{ secrets.PROD_DB_PORT }}" >> $GITHUB_ENV
            echo "DB_USER=${{ secrets.PROD_DB_USER }}" >> $GITHUB_ENV
            echo "DB_PASSWORD=${{ secrets.PROD_DB_PASSWORD }}" >> $GITHUB_ENV
            echo "DB_NAME=${{ secrets.PROD_DB_NAME }}" >> $GITHUB_ENV
          else
            echo "DB_HOST=${{ secrets.STAGING_DB_HOST }}" >> $GITHUB_ENV
            echo "DB_PORT=${{ secrets.STAGING_DB_PORT }}" >> $GITHUB_ENV
            echo "DB_USER=${{ secrets.STAGING_DB_USER }}" >> $GITHUB_ENV
            echo "DB_PASSWORD=${{ secrets.STAGING_DB_PASSWORD }}" >> $GITHUB_ENV
            echo "DB_NAME=${{ secrets.STAGING_DB_NAME }}" >> $GITHUB_ENV
          fi

      - name: 安装PostgreSQL客户端
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      - name: 数据库连接检查
        id: check
        env:
          PGPASSWORD: ${{ env.DB_PASSWORD }}
        run: |
          echo "检查数据库连接..."

          # 测试数据库连接
          if psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c "SELECT 1;" > /dev/null 2>&1; then
            echo "✅ 数据库连接正常"
            CAN_PROCEED="true"
          else
            echo "❌ 数据库连接失败"
            CAN_PROCEED="false"
          fi

          if [ "$CAN_PROCEED" = "true" ]; then
            # 获取数据库大小
            DB_SIZE=$(psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -t -c "SELECT pg_size_pretty(pg_database_size('$DB_NAME'));" | tr -d ' ')
            echo "数据库大小: $DB_SIZE"
            
            # 获取活跃连接数
            ACTIVE_CONNECTIONS=$(psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -t -c "SELECT count(*) FROM pg_stat_activity WHERE state = 'active';" | tr -d ' ')
            echo "活跃连接数: $ACTIVE_CONNECTIONS"
            
            # 检查是否有长时间运行的查询
            LONG_QUERIES=$(psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -t -c "SELECT count(*) FROM pg_stat_activity WHERE state = 'active' AND now() - query_start > interval '5 minutes';" | tr -d ' ')
            
            if [ "$LONG_QUERIES" -gt 0 ]; then
              echo "⚠️ 发现 $LONG_QUERIES 个长时间运行的查询"
              if [ "$ENVIRONMENT" = "production" ] && [ "$MAINTENANCE_TYPE" != "emergency" ]; then
                echo "❌ 生产环境存在长查询，建议稍后重试"
                CAN_PROCEED="false"
              fi
            fi
            
            # 检查磁盘空间
            DISK_USAGE=$(psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -t -c "SELECT round(100.0 * (1 - (pg_database_size('$DB_NAME')::float / (1024*1024*1024*100)))) as disk_usage_percent;" | tr -d ' ' 2>/dev/null || echo "0")
            
            echo "磁盘使用率估算: $DISK_USAGE%"
            
            echo "can-proceed=$CAN_PROCEED" >> $GITHUB_OUTPUT
            echo "db-size=$DB_SIZE" >> $GITHUB_OUTPUT
            echo "active-connections=$ACTIVE_CONNECTIONS" >> $GITHUB_OUTPUT
          else
            echo "can-proceed=false" >> $GITHUB_OUTPUT
          fi

      - name: 生产环境额外检查
        if: env.ENVIRONMENT == 'production'
        env:
          PGPASSWORD: ${{ env.DB_PASSWORD }}
        run: |
          echo "执行生产环境额外检查..."

          # 检查复制状态（如果有）
          REPLICATION_STATUS=$(psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -t -c "SELECT count(*) FROM pg_stat_replication;" | tr -d ' ' 2>/dev/null || echo "0")
          echo "复制连接数: $REPLICATION_STATUS"

          # 检查锁等待
          LOCK_WAITS=$(psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -t -c "SELECT count(*) FROM pg_locks WHERE NOT granted;" | tr -d ' ')
          echo "锁等待数: $LOCK_WAITS"

          if [ "$LOCK_WAITS" -gt 5 ]; then
            echo "⚠️ 发现较多锁等待，建议稍后执行维护"
          fi

  # ===== 维护前备份 =====
  pre-maintenance-backup:
    name: 维护前备份
    runs-on: ubuntu-latest
    needs: pre-check
    if: needs.pre-check.outputs.can-proceed == 'true' && env.SKIP_BACKUP != 'true'
    outputs:
      backup-file: ${{ steps.backup.outputs.backup-file }}

    steps:
      - name: 检出代码
        uses: actions/checkout@v4

      - name: 设置环境变量
        run: |
          if [ "$ENVIRONMENT" = "production" ]; then
            echo "DB_HOST=${{ secrets.PROD_DB_HOST }}" >> $GITHUB_ENV
            echo "DB_PORT=${{ secrets.PROD_DB_PORT }}" >> $GITHUB_ENV
            echo "DB_USER=${{ secrets.PROD_DB_USER }}" >> $GITHUB_ENV
            echo "DB_PASSWORD=${{ secrets.PROD_DB_PASSWORD }}" >> $GITHUB_ENV
            echo "DB_NAME=${{ secrets.PROD_DB_NAME }}" >> $GITHUB_ENV
          else
            echo "DB_HOST=${{ secrets.STAGING_DB_HOST }}" >> $GITHUB_ENV
            echo "DB_PORT=${{ secrets.STAGING_DB_PORT }}" >> $GITHUB_ENV
            echo "DB_USER=${{ secrets.STAGING_DB_USER }}" >> $GITHUB_ENV
            echo "DB_PASSWORD=${{ secrets.STAGING_DB_PASSWORD }}" >> $GITHUB_ENV
            echo "DB_NAME=${{ secrets.STAGING_DB_NAME }}" >> $GITHUB_ENV
          fi

      - name: 安装PostgreSQL客户端
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      - name: 创建维护前备份
        id: backup
        env:
          PGPASSWORD: ${{ env.DB_PASSWORD }}
        run: |
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          BACKUP_FILE="maintenance-backup-${ENVIRONMENT}-${TIMESTAMP}.sql.gz"

          echo "创建维护前备份: $BACKUP_FILE"

          # 创建备份
          pg_dump -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" --verbose | gzip > "$BACKUP_FILE"

          # 验证备份文件
          if [ -f "$BACKUP_FILE" ]; then
            BACKUP_SIZE=$(stat -c%s "$BACKUP_FILE")
            echo "备份文件大小: $BACKUP_SIZE bytes"
            
            if [ $BACKUP_SIZE -lt 1000 ]; then
              echo "❌ 备份文件太小，可能备份失败"
              exit 1
            fi
            
            echo "✅ 备份创建成功"
            echo "backup-file=$BACKUP_FILE" >> $GITHUB_OUTPUT
          else
            echo "❌ 备份文件未创建"
            exit 1
          fi

      - name: 上传备份文件
        uses: actions/upload-artifact@v3
        with:
          name: maintenance-backup-${{ env.ENVIRONMENT }}
          path: ${{ steps.backup.outputs.backup-file }}
          retention-days: 7

  # ===== 常规维护 =====
  routine-maintenance:
    name: 常规维护
    runs-on: ubuntu-latest
    needs: [pre-check, pre-maintenance-backup]
    if: always() && needs.pre-check.outputs.can-proceed == 'true' && (env.MAINTENANCE_TYPE == 'routine' || env.MAINTENANCE_TYPE == 'emergency')

    steps:
      - name: 设置环境变量
        run: |
          if [ "$ENVIRONMENT" = "production" ]; then
            echo "DB_HOST=${{ secrets.PROD_DB_HOST }}" >> $GITHUB_ENV
            echo "DB_PORT=${{ secrets.PROD_DB_PORT }}" >> $GITHUB_ENV
            echo "DB_USER=${{ secrets.PROD_DB_USER }}" >> $GITHUB_ENV
            echo "DB_PASSWORD=${{ secrets.PROD_DB_PASSWORD }}" >> $GITHUB_ENV
            echo "DB_NAME=${{ secrets.PROD_DB_NAME }}" >> $GITHUB_ENV
          else
            echo "DB_HOST=${{ secrets.STAGING_DB_HOST }}" >> $GITHUB_ENV
            echo "DB_PORT=${{ secrets.STAGING_DB_PORT }}" >> $GITHUB_ENV
            echo "DB_USER=${{ secrets.STAGING_DB_USER }}" >> $GITHUB_ENV
            echo "DB_PASSWORD=${{ secrets.STAGING_DB_PASSWORD }}" >> $GITHUB_ENV
            echo "DB_NAME=${{ secrets.STAGING_DB_NAME }}" >> $GITHUB_ENV
          fi

      - name: 安装PostgreSQL客户端
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      - name: 统计信息更新
        env:
          PGPASSWORD: ${{ env.DB_PASSWORD }}
        run: |
          echo "更新表统计信息..."

          # 更新所有表的统计信息
          psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c "ANALYZE;"

          echo "✅ 统计信息更新完成"

      - name: 清理过期数据
        env:
          PGPASSWORD: ${{ env.DB_PASSWORD }}
        run: |
          echo "清理过期数据..."

          # 清理过期的会话记录（保留30天）
          DELETED_SESSIONS=$(psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -t -c "DELETE FROM user_sessions WHERE created_at < NOW() - INTERVAL '30 days'; SELECT ROW_COUNT();" | tr -d ' ' 2>/dev/null || echo "0")
          echo "清理过期会话: $DELETED_SESSIONS 条"

          # 清理过期的日志记录（保留90天）
          DELETED_LOGS=$(psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -t -c "DELETE FROM logs WHERE created_at < NOW() - INTERVAL '90 days' RETURNING 1;" | wc -l 2>/dev/null || echo "0")
          echo "清理过期日志: $DELETED_LOGS 条"

          # 清理过期的DNS记录操作历史（保留180天）
          DELETED_HISTORY=$(psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -t -c "DELETE FROM dns_record_history WHERE created_at < NOW() - INTERVAL '180 days' RETURNING 1;" | wc -l 2>/dev/null || echo "0")
          echo "清理过期DNS历史: $DELETED_HISTORY 条"

          echo "✅ 过期数据清理完成"

      - name: 索引优化
        env:
          PGPASSWORD: ${{ env.DB_PASSWORD }}
        run: |
          echo "检查索引使用情况..."

          # 查找未使用的索引
          UNUSED_INDEXES=$(psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -t -c "
            SELECT schemaname||'.'||tablename||'.'||indexname as index_name
            FROM pg_stat_user_indexes 
            WHERE idx_scan = 0 AND schemaname = 'public'
            AND indexname NOT LIKE '%_pkey';" | tr -d ' ')

          if [ -n "$UNUSED_INDEXES" ]; then
            echo "发现未使用的索引:"
            echo "$UNUSED_INDEXES"
            
            # 在非生产环境删除未使用的索引
            if [ "$ENVIRONMENT" != "production" ]; then
              echo "$UNUSED_INDEXES" | while read -r index; do
                if [ -n "$index" ]; then
                  echo "删除未使用索引: $index"
                  psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c "DROP INDEX IF EXISTS $index;"
                fi
              done
            fi
          else
            echo "✅ 未发现未使用的索引"
          fi

      - name: 数据库膨胀检查
        env:
          PGPASSWORD: ${{ env.DB_PASSWORD }}
        run: |
          echo "检查表膨胀情况..."

          # 检查表膨胀
          psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c "
            SELECT 
              schemaname,
              tablename,
              pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size,
              pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) as table_size
            FROM pg_tables 
            WHERE schemaname = 'public'
            ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC
            LIMIT 10;"

  # ===== 深度维护 =====
  deep-maintenance:
    name: 深度维护
    runs-on: ubuntu-latest
    needs: [pre-check, pre-maintenance-backup, routine-maintenance]
    if: always() && needs.pre-check.outputs.can-proceed == 'true' && (env.MAINTENANCE_TYPE == 'deep' || env.MAINTENANCE_TYPE == 'vacuum' || env.MAINTENANCE_TYPE == 'reindex')

    steps:
      - name: 设置环境变量
        run: |
          if [ "$ENVIRONMENT" = "production" ]; then
            echo "DB_HOST=${{ secrets.PROD_DB_HOST }}" >> $GITHUB_ENV
            echo "DB_PORT=${{ secrets.PROD_DB_PORT }}" >> $GITHUB_ENV
            echo "DB_USER=${{ secrets.PROD_DB_USER }}" >> $GITHUB_ENV
            echo "DB_PASSWORD=${{ secrets.PROD_DB_PASSWORD }}" >> $GITHUB_ENV
            echo "DB_NAME=${{ secrets.PROD_DB_NAME }}" >> $GITHUB_ENV
          else
            echo "DB_HOST=${{ secrets.STAGING_DB_HOST }}" >> $GITHUB_ENV
            echo "DB_PORT=${{ secrets.STAGING_DB_PORT }}" >> $GITHUB_ENV
            echo "DB_USER=${{ secrets.STAGING_DB_USER }}" >> $GITHUB_ENV
            echo "DB_PASSWORD=${{ secrets.STAGING_DB_PASSWORD }}" >> $GITHUB_ENV
            echo "DB_NAME=${{ secrets.STAGING_DB_NAME }}" >> $GITHUB_ENV
          fi

      - name: 安装PostgreSQL客户端
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      - name: VACUUM 操作
        if: env.MAINTENANCE_TYPE == 'deep' || env.MAINTENANCE_TYPE == 'vacuum'
        env:
          PGPASSWORD: ${{ env.DB_PASSWORD }}
        run: |
          echo "执行VACUUM操作..."

          # 获取主要表列表
          TABLES=$(psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -t -c "SELECT tablename FROM pg_tables WHERE schemaname = 'public' ORDER BY tablename;")

          echo "开始VACUUM操作..."
          for table in $TABLES; do
            echo "VACUUM表: $table"
            if [ "$ENVIRONMENT" = "production" ]; then
              # 生产环境使用非阻塞VACUUM
              psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c "VACUUM (VERBOSE) $table;"
            else
              # 非生产环境可以使用VACUUM FULL
              psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c "VACUUM FULL VERBOSE $table;"
            fi
          done

          echo "✅ VACUUM操作完成"

      - name: 重建索引
        if: env.MAINTENANCE_TYPE == 'deep' || env.MAINTENANCE_TYPE == 'reindex'
        env:
          PGPASSWORD: ${{ env.DB_PASSWORD }}
        run: |
          echo "重建索引..."

          # 获取需要重建的索引
          INDEXES=$(psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -t -c "
            SELECT indexname 
            FROM pg_indexes 
            WHERE schemaname = 'public' 
            AND indexname NOT LIKE '%_pkey'
            ORDER BY indexname;")

          for index in $INDEXES; do
            if [ -n "$index" ] && [ "$index" != " " ]; then
              echo "重建索引: $index"
              if [ "$ENVIRONMENT" = "production" ]; then
                # 生产环境使用CONCURRENTLY重建
                psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c "REINDEX INDEX CONCURRENTLY $index;" || echo "索引 $index 重建失败"
              else
                psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c "REINDEX INDEX $index;"
              fi
            fi
          done

          echo "✅ 索引重建完成"

      - name: 检查数据完整性
        env:
          PGPASSWORD: ${{ env.DB_PASSWORD }}
        run: |
          echo "检查数据完整性..."

          # 检查外键约束
          CONSTRAINT_VIOLATIONS=$(psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -t -c "
            SELECT COUNT(*) FROM (
              SELECT conname, conrelid::regclass, confrelid::regclass
              FROM pg_constraint
              WHERE contype = 'f'
            ) constraints;" | tr -d ' ')

          echo "外键约束数量: $CONSTRAINT_VIOLATIONS"

          # 检查表行数统计
          echo "主要表行数统计:"
          psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c "
            SELECT 
              schemaname,
              tablename,
              n_tup_ins as inserts,
              n_tup_upd as updates,
              n_tup_del as deletes,
              n_live_tup as live_rows,
              n_dead_tup as dead_rows
            FROM pg_stat_user_tables 
            WHERE schemaname = 'public'
            ORDER BY n_live_tup DESC;"

  # ===== 维护后检查 =====
  post-maintenance-check:
    name: 维护后检查
    runs-on: ubuntu-latest
    needs: [pre-check, routine-maintenance, deep-maintenance]
    if: always() && needs.pre-check.outputs.can-proceed == 'true'

    steps:
      - name: 设置环境变量
        run: |
          if [ "$ENVIRONMENT" = "production" ]; then
            echo "DB_HOST=${{ secrets.PROD_DB_HOST }}" >> $GITHUB_ENV
            echo "DB_PORT=${{ secrets.PROD_DB_PORT }}" >> $GITHUB_ENV
            echo "DB_USER=${{ secrets.PROD_DB_USER }}" >> $GITHUB_ENV
            echo "DB_PASSWORD=${{ secrets.PROD_DB_PASSWORD }}" >> $GITHUB_ENV
            echo "DB_NAME=${{ secrets.PROD_DB_NAME }}" >> $GITHUB_ENV
          else
            echo "DB_HOST=${{ secrets.STAGING_DB_HOST }}" >> $GITHUB_ENV
            echo "DB_PORT=${{ secrets.STAGING_DB_PORT }}" >> $GITHUB_ENV
            echo "DB_USER=${{ secrets.STAGING_DB_USER }}" >> $GITHUB_ENV
            echo "DB_PASSWORD=${{ secrets.STAGING_DB_PASSWORD }}" >> $GITHUB_ENV
            echo "DB_NAME=${{ secrets.STAGING_DB_NAME }}" >> $GITHUB_ENV
          fi

      - name: 安装PostgreSQL客户端
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      - name: 验证数据库状态
        env:
          PGPASSWORD: ${{ env.DB_PASSWORD }}
        run: |
          echo "验证数据库状态..."

          # 检查数据库连接
          if psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c "SELECT 1;" > /dev/null 2>&1; then
            echo "✅ 数据库连接正常"
          else
            echo "❌ 数据库连接失败"
            exit 1
          fi

          # 检查表可访问性
          TABLES_COUNT=$(psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';" | tr -d ' ')
          echo "可访问表数量: $TABLES_COUNT"

          # 检查索引状态
          INDEXES_COUNT=$(psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -t -c "SELECT COUNT(*) FROM pg_indexes WHERE schemaname = 'public';" | tr -d ' ')
          echo "索引数量: $INDEXES_COUNT"

          # 检查维护后的数据库大小
          NEW_DB_SIZE=$(psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -t -c "SELECT pg_size_pretty(pg_database_size('$DB_NAME'));" | tr -d ' ')
          echo "维护后数据库大小: $NEW_DB_SIZE"
          echo "维护前数据库大小: ${{ needs.pre-check.outputs.db-size }}"

      - name: 性能测试
        env:
          PGPASSWORD: ${{ env.DB_PASSWORD }}
        run: |
          echo "执行维护后性能测试..."

          # 简单查询性能测试
          START_TIME=$(date +%s%N)
          psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c "SELECT COUNT(*) FROM domains;" > /dev/null
          END_TIME=$(date +%s%N)
          QUERY_TIME=$(( (END_TIME - START_TIME) / 1000000 ))
          echo "域名表查询时间: ${QUERY_TIME}ms"

          # 索引查询性能测试
          START_TIME=$(date +%s%N)
          psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c "SELECT * FROM domains WHERE user_id = 1 LIMIT 1;" > /dev/null
          END_TIME=$(date +%s%N)
          INDEX_QUERY_TIME=$(( (END_TIME - START_TIME) / 1000000 ))
          echo "索引查询时间: ${INDEX_QUERY_TIME}ms"

          if [ $QUERY_TIME -gt 1000 ]; then
            echo "⚠️ 查询性能较慢"
          else
            echo "✅ 查询性能正常"
          fi

  # ===== 生成维护报告 =====
  generate-maintenance-report:
    name: 生成维护报告
    runs-on: ubuntu-latest
    needs:
      [pre-check, routine-maintenance, deep-maintenance, post-maintenance-check]
    if: always()

    steps:
      - name: 生成维护报告
        run: |
          echo "# 🔧 Database Maintenance Report" > maintenance-report.md
          echo "" >> maintenance-report.md
          echo "**维护时间**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> maintenance-report.md
          echo "**环境**: $ENVIRONMENT" >> maintenance-report.md
          echo "**维护类型**: $MAINTENANCE_TYPE" >> maintenance-report.md
          echo "**跳过备份**: $SKIP_BACKUP" >> maintenance-report.md
          echo "" >> maintenance-report.md

          echo "## 📋 维护执行状态" >> maintenance-report.md
          echo "" >> maintenance-report.md
          echo "| 维护项目 | 状态 | 说明 |" >> maintenance-report.md
          echo "|---------|------|------|" >> maintenance-report.md
          echo "| 预检查 | ${{ needs.pre-check.result == 'success' && '✅ 通过' || '❌ 失败' }} | 维护前环境检查 |" >> maintenance-report.md
          echo "| 备份 | ${{ needs.pre-maintenance-backup.result == 'success' && '✅ 完成' || needs.pre-maintenance-backup.result == 'skipped' && '⏭️ 跳过' || '❌ 失败' }} | 维护前数据备份 |" >> maintenance-report.md
          echo "| 常规维护 | ${{ needs.routine-maintenance.result == 'success' && '✅ 完成' || needs.routine-maintenance.result == 'skipped' && '⏭️ 跳过' || '❌ 失败' }} | 统计更新、数据清理 |" >> maintenance-report.md
          echo "| 深度维护 | ${{ needs.deep-maintenance.result == 'success' && '✅ 完成' || needs.deep-maintenance.result == 'skipped' && '⏭️ 跳过' || '❌ 失败' }} | VACUUM、重建索引 |" >> maintenance-report.md
          echo "| 后检查 | ${{ needs.post-maintenance-check.result == 'success' && '✅ 通过' || '❌ 失败' }} | 维护后状态验证 |" >> maintenance-report.md
          echo "" >> maintenance-report.md

          echo "## 📊 数据库状态" >> maintenance-report.md
          echo "" >> maintenance-report.md
          echo "- **维护前大小**: ${{ needs.pre-check.outputs.db-size }}" >> maintenance-report.md
          echo "- **活跃连接数**: ${{ needs.pre-check.outputs.active-connections }}" >> maintenance-report.md
          echo "- **备份文件**: ${{ needs.pre-maintenance-backup.outputs.backup-file || '未创建' }}" >> maintenance-report.md
          echo "" >> maintenance-report.md

          # 维护结果摘要
          OVERALL_SUCCESS="true"
          if [ "${{ needs.pre-check.result }}" != "success" ]; then
            OVERALL_SUCCESS="false"
          fi
          if [ "${{ needs.routine-maintenance.result }}" = "failure" ]; then
            OVERALL_SUCCESS="false"
          fi
          if [ "${{ needs.deep-maintenance.result }}" = "failure" ]; then
            OVERALL_SUCCESS="false"
          fi
          if [ "${{ needs.post-maintenance-check.result }}" != "success" ]; then
            OVERALL_SUCCESS="false"
          fi

          echo "## 📈 维护结果" >> maintenance-report.md
          echo "" >> maintenance-report.md
          if [ "$OVERALL_SUCCESS" = "true" ]; then
            echo "🟢 **维护状态**: 成功完成" >> maintenance-report.md
            echo "" >> maintenance-report.md
            echo "✅ 所有维护任务已成功执行" >> maintenance-report.md
            echo "✅ 数据库状态正常" >> maintenance-report.md
            echo "✅ 性能检查通过" >> maintenance-report.md
          else
            echo "🔴 **维护状态**: 部分失败" >> maintenance-report.md
            echo "" >> maintenance-report.md
            echo "⚠️ 部分维护任务执行失败，请检查日志" >> maintenance-report.md
            echo "⚠️ 建议手动验证数据库状态" >> maintenance-report.md
          fi
          echo "" >> maintenance-report.md

          echo "## 🔄 下次维护建议" >> maintenance-report.md
          echo "" >> maintenance-report.md
          echo "- **常规维护**: 每日自动执行" >> maintenance-report.md
          echo "- **深度维护**: 每周执行" >> maintenance-report.md
          echo "- **紧急维护**: 根据监控告警按需执行" >> maintenance-report.md
          echo "" >> maintenance-report.md
          echo "---" >> maintenance-report.md
          echo "*报告生成时间: $(date -u '+%Y-%m-%d %H:%M:%S UTC')*" >> maintenance-report.md

      - name: 上传维护报告
        uses: actions/upload-artifact@v3
        with:
          name: maintenance-report-${{ env.ENVIRONMENT }}
          path: maintenance-report.md

      - name: 发送维护通知
        if: env.ENVIRONMENT == 'production' && secrets.SLACK_WEBHOOK_URL
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              "text": "🔧 Domain MAX 数据库维护完成",
              "attachments": [
                {
                  "color": "${{ (needs.pre-check.result == 'success' && (needs.routine-maintenance.result == 'success' || needs.routine-maintenance.result == 'skipped') && (needs.deep-maintenance.result == 'success' || needs.deep-maintenance.result == 'skipped') && needs.post-maintenance-check.result == 'success') && 'good' || 'danger' }}",
                  "fields": [
                    {
                      "title": "环境",
                      "value": "${{ env.ENVIRONMENT }}",
                      "short": true
                    },
                    {
                      "title": "维护类型",
                      "value": "${{ env.MAINTENANCE_TYPE }}",
                      "short": true
                    },
                    {
                      "title": "数据库大小",
                      "value": "${{ needs.pre-check.outputs.db-size }}",
                      "short": true
                    },
                    {
                      "title": "维护状态",
                      "value": "${{ (needs.pre-check.result == 'success' && (needs.routine-maintenance.result == 'success' || needs.routine-maintenance.result == 'skipped') && (needs.deep-maintenance.result == 'success' || needs.deep-maintenance.result == 'skipped') && needs.post-maintenance-check.result == 'success') && '成功' || '部分失败' }}",
                      "short": true
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
